from workflows.example import preprocess_data, send_data
import os
import glob


def test_preprocess_data():
    # I want to test that the returned directory is not empty and it has the expected
    # subdirectories and transforms.json file in it

    # I think I should make a fixture that has some test data in it I guess...

    # Arrange
    # raw_data_dir = FlyteDirectory(path="/Users/andrewma/Desktop/nerfstudio-demo/2024-03-17--18-25-12/EXR_RGBD")
    raw_data_dir = (
        "/Users/andrewma/Desktop/nerfstudio-demo/2024-03-17--18-25-12/EXR_RGBD"
    )
    # Act

    # testing this task like a python function still uses the temp dir for the current
    # context working directory

    # I can't be sure but I suppose using pyflyte run handles some of the package
    # discovery issues? I suppose it also allows you to configure things about the run
    # and use config files for the run

    preprocessed_data_dir = preprocess_data(raw_data_dir=raw_data_dir)
    path = preprocessed_data_dir.path
    # Assert
    assert os.path.isdir(os.path.join(path, "images"))
    assert os.path.isdir(os.path.join(path, "images_2"))
    assert os.path.isdir(os.path.join(path, "images_4"))
    assert os.path.isdir(os.path.join(path, "images_8"))
    assert os.path.isfile(os.path.join(path, "transforms.json"))


def test_send_data(tmp_path):
    # In the future, it's probably safer if I use a fixture and copy in my test set data
    # to the temp directory and then use the teardown feature of fixtures to clean up the
    # zipped file that are generated by the send_data task

    # Arrange Flyte automatically converts directories to FlyteDirectory objects. Please
    # see: https://docs.flyte.org/en/latest/user_guide/data_types_and_io/index.html
    # Act
    output = send_data(preprocessed_data=tmp_path)
    # Assert
    assert "runpodctl receive" in output

    # Teardown
    for file in glob.glob("*.zip"):
        os.remove(file)


# I think that if I wanted to test the task inside of a workflow, I would need to use
# the flyte.testing module.

# In fact for testing the logic of the workflow, it might be a good practice to use
# mocked tasks and check that the logic totally holds

# I also might need to write an end-to-end test later... but I'm not so sure yet,
# because I don't know how to end-to-end test the result of runpod
